# 객체망과 객체간 통신

![image-20190908235041334](https://tva1.sinaimg.cn/large/006y8mN6gy1g6shxfjtkaj31580h8dh1.jpg)



**객체는 내부상태는 캡슐화 즉, private 등의 접근제어자로 캡슐화하고, 외부와의 소통은 public 해서 메세지를 전달한다.**



![image-20190908235222664](https://tva1.sinaimg.cn/large/006y8mN6gy1g6shz6oyxuj30zq0gst9s.jpg)



이 책에서는 협력, 역할, 책임에 대해서 설명하는데, 이때 역할과 책임은 다른 것이다.



예를 들어 `나` 라는 존재는 *회사에서는 사장이고, 집에서는 가장이다.*

즉, 보는 시점에 따라 `나` 라는 데이터는 서로 다른 역할을 하는 것이다.



![image-20190908235512147](https://tva1.sinaimg.cn/large/006y8mN6gy1g6si244cetj30zk0hqta9.jpg) 



역할 별로 여러개로 분리되어 구현되어 있지만, 이걸 인터페이스A,인터페이스B,인터페이스C 등의 형으로 생각할 수 있다. 그리고 이 모든 것을 통틀어서 역할이라고 할 수 있다.



각각의 역할은 책임과 권한을 지니고 있다.



그러나, 실제 통신은 객체가 다각도로 통신한다. 그래서 객체지향 프로그래밍이 어려운 이유이다.

*아름답게 아빠와 아들이 통신하는게, 아니라 이 세계에서는 어떤 규격 없이 통신 한다.*

![image-20190908235730569](https://tva1.sinaimg.cn/large/006y8mN6gy1g6si4j8jhij31180gyjsw.jpg)



인터페이스A 는 어느날, 갑자기 인터페이스b에게 메세지를 전달해야 될 수도 있다.



***우리가 위키에 많은 내용을 적는다는 건 코드를 Type으로 짜지않고, 정적으로 짜고 있다는 증거이다.*** 



위에는 2개를 예시로 했었지만, 실제로는 여러개의 객체가 존재하는데, 아래와 같이 4개 3개 등으로 많은 통신망의 구성을 생각해야 한다.

![image-20190909000758920](https://tva1.sinaimg.cn/large/006y8mN6gy1g6siff8cbzj313y0h6jsa.jpg)



위 그림에서 **첫번째는 순환이 없지만** **두번째 그림을 보면 순환이 존재한다.**

 객체를 설계하는데, 단방향, 양방향이 있을 수 있는데, 

***결코 순환참조하는 객체망은 존재해서는 안된다.***  또한 양방향도 존재해서는 안된다.

 지금 당장은 버그가 없을 수 있지만, 내일은 버그가 있을 수 확률이 높다. 그러므로 처음부터 단방향만을 생각하고 객체를 설계해야 한다.



## 객체설계 난점

위 내용을 알아도 우리는 엄청난 난점을 가지고 있다.

**인터페이스는 하나만 갖는 것이 좋다.**



똑같은 대상일지라도, 많은 책임이 존재한다.

**ABCD라는 인터페이스는 서로 다른 도메인/네트윅/모델링 관점에서 다를 수 있다.** 서로 다른 양상으로 많이 만들어 질수 있다.



![image-20190909002206862](https://tva1.sinaimg.cn/large/006y8mN6gy1g6siu581nej30km0hqgms.jpg)



그러나, 문제는 하나의 객체는 본질적인 데이터에 따라 수용해야하는 다양한 인터페이스가 다를 것이다.



![image-20190909002400522](https://tva1.sinaimg.cn/large/006y8mN6gy1g6siw3bnexj317m0iomzf.jpg)



그리고 여러 관점을 수용하는 객체는



![image-20190909002454802](https://tva1.sinaimg.cn/large/006y8mN6gy1g6six15fbqj31860i4wgu.jpg)



하나의 망이 되서 인터페이스의 그룹화와 상호작용한다.

이 문제가 바로 설계를 어렵게 하는 요소이다.



![image-20190909002533784](https://tva1.sinaimg.cn/large/006y8mN6gy1g6sixprlkij317g0iun0k.jpg)



그래서 알려진 기본 설계요령을 우리는 외워야 한다.



# SOLID 원칙

## SRP - Single Responsiblity 단일 책임

클래스는 단 하가지의 변경 이유만 가져야 한다는 것. 이를 이해한다면 단일 책임 원칙이 클래스의 응집도를 높일 수 있는 설계 원칙이라는 사실을 이해할 수 있다.

**객체가 변동되는 이유가 있을 때만 변경되어야 한다.**

SRP는 산탄총 수술(shotgun surgery) 이라고도 한다.

변경하는 이유는 하나가 되도록 클래스를 나눠야 한다.

## OCP - Open Closed 개방 폐쇄

수정에는 막혀있고, 확장에는 열려있어야 한다. 라고 말하는 것.

다형성이라고 생각해도 무관하다.

point of point를 참조한다면 우리는 OCP를 지킬 수 있다.

구현보다는 인터페이스를 참조하는것이 좋다.

## LSP - Liskov Substitusion 업캐스팅 안전

부모클래스에는 자식클래스를 집어 넣을 수 있다.  

![image-20190909003754915](https://tva1.sinaimg.cn/large/006y8mN6gy1g6sjak14eaj30po0hodi2.jpg)



인터페이스는 모두의 교집합만이 만족할 수 있는 코드가 있어야 한다.

2개의 인터페이스를 만들어서 해야 한다.

![image-20190909003901712](https://tva1.sinaimg.cn/large/006y8mN6gy1g6sjbq28s0j30q40gwtau.jpg)



리스코프 치환원칙은 굉장히 어려운 것이다~~~~~~~~~~~~~~

실수, 정수, 무리수 등을 설명하는 것이 어려운 것과 마찬가지이다.



## ISP - interface Segregation 인터페이스 분리



어떤 객체의 메소드가 6개가 있습니다. 이 중 2개는 모듈A, 2개는 모듈B, 2개는 모듈C에서 동작한다고 가정하자.

이 때 접근하는 객체가 다양할 수 있는데 우리는 이 접근을 형(type)으로 막아야 한다.

![image-20190909004620314](https://tva1.sinaimg.cn/large/006y8mN6gy1g6sjjbtofoj31780iq42c.jpg)



## DIP - Dependency Inversion 다운 캐스팅 금지

![image-20190909004952732](https://tva1.sinaimg.cn/large/006y8mN6gy1g6sjn16cejj30p80boq4j.jpg)



잘 알고 있지만, 실현하기는 어렵다.



그 외에

![image-20190909005136516](https://tva1.sinaimg.cn/large/006y8mN6gy1g6sjotlpcrj30hi0hmwgm.jpg)



`Don't Repeat Yourself` / `Hollywood Principle` - 물어보지말고 시키는 코드를 작성해라.

getter 는 사실 좋은게 아니다. 확정지을 수 있는 상황이 없더라면

`Law of demeter` 최소 지식을 요구한다.

`중계무역이 아니라 직거래를 해라` 라는 의미. 

즉, 격리 벽이 존재해야 한다. 그 안쪽을 못보게 해야 한다.

*좀 더 의존성 부패방지와 최소 지식의 모순에 대해서 이야기 해보자.*

![image-20190909010057086](https://tva1.sinaimg.cn/large/006y8mN6gy1g6sjyj6ptqj318k0i0gnd.jpg)



우리가 지금까지 규칙을 잘 지켰다면 메세지를 잘 주고 받을 것이다. 

그러나, 우리가 던진 메세지가 잘 던졌는지 확인해야 할 필요가 있다. 당시 통신 할 때, 각각의 메세지가 활성화되어 있는지, 안을 볼 수 있는 방법이 없다.

![image-20190909011548277](https://tva1.sinaimg.cn/large/006y8mN6gy1g6ske1r607j313y0h8mzv.jpg)



객체망이 있다면, 결국 제대로 작동하는지 테스트하려면, 테스트할 객체에게 메세지를 보낸 뒤에, 그 객체가 이웃 객체에게 메세지를 잘 보냈는지 확인한다.

객체망에서 테스트는 회색박스가 트리거가 되어 파란색 빨간색이 내가 의도한 데이터가 잘 도착했다면, 오케이?



그러나,

![image-20190909011906279](https://tva1.sinaimg.cn/large/006y8mN6gy1g6skhfdfxqj315e0hsjv6.jpg)



단위 테스트를 위해서 Mock객체를 쓰는 이유를 고려해본적이 있는가?



테스트에는 mockery, mock 이라는 용어가 나온다.

![image-20190909012133236](https://tva1.sinaimg.cn/large/006y8mN6gy1g6skjyve9cj31520go0wf.jpg)



객체가 잘 동작하다는 것은 오직 Mock 테스트를 통해서만 확인할 수 있다. 이 말은 반대로 Mock 없이는 정상 작동한다는 것을 확인 할 수 없다.



선택이 아니고 환경이 아니다. Mock 이 있어야지만 객체지향을 만족시킬 수 있다.



![image-20190909012807526](https://tva1.sinaimg.cn/large/006y8mN6gy1g6skqsuy37j30wq0ikq3k.jpg)



***SOLID 원칙과 비슷한 의미를 가진 패턴 - GRASP***

cf) 캔드백이 말하는 가치 는. - 돈이 되는 방향으로 가야해. / 

![image-20190909013038024](https://tva1.sinaimg.cn/large/006y8mN6gy1g6sktemhftj30og0g4jtr.jpg)





## 0. Information Expert - 조화.

해당 정보를 갖고 있는 객체에게 책임을 할당하라. 객체의 본질과 데이터 은닉을 지킬 수 있는 패턴.

무조건 지킬수는 없지만, 되도록이면 정보를 가지고 있는 객체가 책임을 지는 것이 좋다.

## 1. Creator

너가 객체를 만들 때도 Information Expert를 활용해야 할 것이다.

객체 시스템의 이질적인 부분인 생성 시에도 정보전문가 패턴을 따라야 한다. 

어떤 객체가 대상을 포함하거나, 이용하거나, 부분으로 삼거나, 잘 알고 있다면 그 대상을 생성하게 시키자.

## 2. Controller

Mediator 패턴의 설계판 확장으로 서브시스템으로 묶을 수 있다면 컨트롤러를 도입하자.

하나의 객체가 여러 객체를 알고 다양하게 유기적으로 연결되어 있다고 가정할 때.

## 3. Low Couping & High Cohesion

결합도를 낮추고 응집도를 높이는 패턴은 다른 양상으로 나타남. 결합도를 낮추려면 아는 객체 수를 줄여야 함. 하지만 더 중요한 것은 단방향 의존성임. 이에 비해 응집도를 높이려면 객체를 도출할 때부터 변화율을 고려해야 함.



***Low Couping을 하기 위해서는 중간에 매개체를 활용해야 한다.***



로우커플링은 형이 더 많이 나오는데, 이것이 맞는 것이다.

## 4. Protected Variations

추상적인 수준에서 책임을 정의하여 다양한 구상 가능성으로부터 사용할 모듈을 보호하라.



직접적인 형을 참조하지말고, 추상적인 수준을 책임하라.



## 5. Polymorphism

전략패턴을 말하는 것. 분기가 예상되는 책임이라면 다형성을 이용하라.



## 6. Pure Fabrication

공통된 기능이나 순수 기능적인 객체는 따로 모아서 작성한다.



## 7. Indirection

직접 참조관계를 피하고 중계 객체를 이용하면 개별 객체의 충격을 중계 객체에서 흡수할 수 있다.
# 서브클래싱과 서브타이핑

상속의 두가지 용도

- 타입계층  
  : 타입 계층의 관점에서 부모 클래스는 자식 클래스의 **일반화(generalization)**이고 자식 클래스는 부모 클래스의 **특수화(specialization)**이다.
- 코드재사용  

`상속을 사용하는 일차적인 목표는 코드 재사용이 아니라 타입 계층을 구현하는 것이어야 한다.`



> 결론부터 말하자면 동일한 메시지에 대해 서로 다르게 행동할 수 있는 다형적인 객체를 구현하기 위해서는 객체의 행동을 기반으로 타입 계층을 구성해야 한다.



## 올바른 타입 계층을 구성하는 원칙?

### 타입 계층이란 무엇인가? 상속을 이용해 타입 계층을 구현한다는 것은 무엇을 의미하는가?



## 타입

- **개념 관점의 타입**  
  \> 우리가 인지하는 세상의 사물의 종류, 다시 말해 우리가 인식하는 객체들에 적용하는 개념이나 아이디어를 가리켜 타입.
  - **심볼** - 타입에 이름을 붙인것
  - **내연** - 타입의 정의로서 타입에 속하는 객체들이 가지는 공통적인 속성이나 행동을 가리킴 (ex, 프로그래밍 언어 는 '컴퓨터에게 특정한 작업을 지시하기 위한 어휘와 문법적인 규칙의 집합')
  - **외연** - 타입에 속하는 객체들의 집합 (ex, 프로그래밍 언어 는 자바, 루비, 자바스크립트 등등등)
- **프로그래밍 언어 관점의 타입**  
  \> 연속적인 비트에 의미와 제약을 부여하기 위해 사용, 프로그래밍 언어의 관점에서 타입은 비트 묶음에 의미를 부여하기 위해 정의된 제약과 규칙을 가리킴
  - 타입에 수행될 수 있는 유효한 오퍼레이션의 집합을 정의 ( + )
  - 타입에 수행되는 오퍼레이션에 대해 미리 약속된 문맥을 제공( ex, a + b )
- **객체지향 패러다임 관점의 타입**
  - 프로그래밍 언어의 관점에서 타입은 호출 가능한 오퍼레이션의 집합을 정의한다. 객체지향 프로그래밍에서 오퍼레이션은 객체가 수신할 수 있는 메시지를 의미한다. 따라서 **객체의 타입**이란 객체가 수신할 수 있는 메시지의 종류를 정의하는 것
  - 메시지의 종류 = **퍼블릭 인터페이스**
  - **객체지향 프로그래밍에서 타입을 정의하는 것은 객체의 퍼블릭 인터페이스를 정의하는 것과 동일**
  - **객체의 퍼블릭 인터페이스가 객체의 타입을 결정한다. 따라서 동일한 퍼블릭 인터페이스를 제공하는 객체들은 동일한 타입으로 분류된다.**
  - 객체에게 중요한 것은 속성이 아니라 행동, 어떤 객체들이 동일한 상태를 가지고 있더라도 **퍼블릭 인터페이스**가 다르다면 이들은 서로 다른 타입으로 분류해야 된다.

## 타입 계층

- **타입 사이의 포함관계**

  \> 타입 안에 포함된 객체들은 좀 더 상세한 기준으로 묶어 새로운 타입을 정의하면 **이 새로운 타입은 자연스럽게 기존 타입의 부분집합이 된다.**

  - 타입 계층을 구성하는 두 타입 간의 관계에서 더 일반적인 타입을 슈퍼타입(supertype)이라고 부르고 더 특수한 타입을 서브타입(subtype)이라고 부름.
  - 집합을 의미하는 외연의 관점에서 일반적인 타입의 인스턴스 집합은 특수한 타입의 인스턴스 집합을 포함하는 **슈퍼셋**, 반대로 특수한 타입의 인스턴스 집합은 일반적인 타입의 인스턴스 집합에 포함된 **서브셋**
  - **일반화**는 다른 타입을 완전히 포함하거나 내포하는 타입을 식별하는 행위 또는 그 행위의 결과를 가르킨다. **특수화**는 다른 타입 안에 전체적으로 포함되거나 완전히 내포되는 타입을 식별하는 행위 또는 그 행위의 결과를 가리킨다.
  - **슈퍼타입**
    - 집합이 다른 집합의 모든 멤버를 포함
    - 타입 정의가 다른 타입보다 좀 더 일반적
  - **서브타입**
    - 집합에 포함되는 인스턴스들이 더 큰 집합에 포함
    - 타입 정의가 다른 타입보더 좀 더 구체적

- **객체지향 프로그래밍과 타입 계층**

  - 객체의 타입을 결정하는 것은 퍼블릭 인터페이스
  - **슈퍼타입**
    - 서브타입이 정의한 퍼블릭 인터페이스를 일반화시켜 상대적으로 범용적이고 넓은 의미로 정의한 것
  - **서브타입**
    - 슈퍼타입이 정의한 퍼블릭 인터페이스를 특수화시켜 상대적으로 구체적으고 좁은 의미로 정의한 것
  - 여전히 포인트는, 일반적인 타입과 구체적인 타입 간의 관계를 형성하는 기준이 **'퍼블릭 인터페이스'**
  - 더 일반적인 퍼블릭 인터페이스를 가지는 객체들은 더 특수한 퍼블릭 인터페이스를 가지는 객체들의 슈퍼타입
  - 서브타입의 인스턴스는 슈퍼타입의 인스턴스로 간주될 수있다. 이게 바로 대체가능성



## 서브클래싱과 서브타이핑

### 그럼, 언제 상속을 사용해야 하는가?

- 

### 



## 리스코프 치환 원칙

예제로 설명해준 부분이 와닿았음. 기록하면 좋을 듯!

- 클라이언트와 대체 가능성
- is-a 관계 다시 살펴보기
- 리스코프 치환 원칙은 유연한 설계의 기반이다.

## 계약에 의한 설계와 서브타이핑

이 부분은 따로 정의한 내용을 참조하는 것이 더욱 도움이 될 것이다.
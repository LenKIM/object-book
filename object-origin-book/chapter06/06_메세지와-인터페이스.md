# 메시지와 인터페이스

 *처음에는 의아할 수도 있지만 객체 지향 어플리케이션의 가장 중요한 재료는 클래스가 아니라 객체들이 주고받는 메시지이다.* 

 애플리케이션은 클래스로 구성되지만 메시지를 통해 정의된다는 사실을 기억하라.

- 객체가 수신하는 메시지들이 객체의 퍼블릭 인터페이스를 구성한다.
- 훌룡한 퍼블릭 인터페이스를 얻기 위해서는 책임 주도 설계 방법을 따르는 것만으로는 부족.



## 00. 협력과 메시지의 기본 개념

### 00.1 클라이언트- 서버 모델

두 객체 사이의 협력 관계를 설명하기 위해 사용하는 전통적인 메타포는 **클라이언트-서버(Client-Server)**    
협력 안에서 메시지를 전송하는 객체를 클라이언트, 메시지를 수신하는 객체를 서버라고 부른다. 협력은 클라이언트가 서버의 서비스를 요청하는 단방향 상호작용

### 00.2 메세지와 메시지 전송  

- **메시지**는 객체들이 협력하기 위해 사용할 수 있는 유일한 의사소통 수단.  

- 한 객체가 다른 객체에 도움을 요청하는 것을 **메시지 전송(message sending) 또는 메세지 패싱(message passing)**

- **메시지**는 *오퍼레이션명과 인자*로 구성되며 **메시지 전송은 여기에 메시지 수신자**를 추가한 것

  

### 00.3 메시지와 메서드

- 메시지를 수신했을 때 실제로 어떤 코드가 실행되는지는 **메시지 수신자의 실제 타입**이 무엇인가에 달려 있다.
- 메시지를 수신했을 때 실제로 실행되는 함수 또는 프로시저를 **메서드**라고 부른다.
- 중요한 것은 코드 상에서 동일한 이름의 변수에게 동일한 메시지를 전송하더라도 객체의 타입에 따라 실행되는 메서드가 달라질 수 있다는 것. condition.isSatisfiedBy(...)
- 전통적인 방식의 개발자는 어떤 코드가 실행될지를 정확하게 알고 있는 상황에서 함수 호출이나 프로시저 호출 구문을 작성한다. 다시 말해 코드의 의미가 컴파일 시점과 실행 시점에 동일하다는 것. **반면**, 객체는 메시지와 메서드라는 두 가지 서로 다른 개념을 실행 시점에 연결해야 하기 때문에 컴파일 시점과 실행 시점의 의미가 달라질 수 있다.
- 실행시점에 실제로 실행되는 코드는 메시지를 수신하는 객체의 타입에 따라 달라지기 때문에 우리는 그저 메시지에 응답할 수 있는 개체가 존재하고 그 객체가 적절한 메서드를 선택해서 응답할 것이라고 믿을 수 밖에 없다.

### 00.4 퍼블릭 인터페이스와 오퍼레이션

- 외부의 객체는 오직 객체가 공개하는 메시지를 통해서만 객체와 상호작용할 수 있다. 이처럼 객체가 의사소통을 위해 외부에 공개하는 메시지의 집합을 **퍼블릭 인터페이스** 라고 부른다.

- 프로그래밍 언어의 관점에서 퍼블릭 인터페이스에 포함된 메시지를 **오퍼레이션** 이라고 부른다. 

- 오퍼레이션은 수행가능한 어떤 행동에 대한 추상화다.

- 흔히 **오퍼레이션**이라고 부를 때는 내부의 구현 코드는 제외하고 단순히 메시지와 관련된 시그니처를 가리키는 경우가 대부분.

- 그에 비해 메시지를 수신했을 때 실제로 실행되는 코드는 **메서드**라고 부른다.

  

### 00.5 시그니처

- 오퍼레이션(또는 메서드)의 이름과 파라미터 목록을 합쳐 시그니처(signature) 라고 부른다.

## 01. 인터페이스와 설계 품질

***좋은 인터페이스는 최소한의 인터페이스와 추상적인 인터페이스 라는 조건을 만족해야 한다.***

- 최소주의를 따르면서도 추상적인 인터페이스를 설계할 수 있는 가장 좋은 방법은 책임주도 설계 방법을 따르는 것, 메시지를 먼저 선택함으로써 협력과는 무관한 오퍼레이션이 인터페이스에 스며드는 것을 방지
- 객체가 메시지를 선택하는 것이 아니라, 메시지가 객체를 선택하게 함으로써 클라이언트의 의도를 메시지를 표현할 수 있게 한다.

아래 4가지가 퍼블릭 인터페이스의 품질에 영향을 미치는 다음과 같은 원칙과 기법에 관해 살펴보자.



### 01.00 디미터 법칙  

```java
public Reservation reserve(Screening screening, Customer customer,
                           int audienceCount) {
  Movie movie = screening.getMovie();

  boolean discountable = false;
  for(DiscountCondition condition : movie.getDiscountConditions()) {
    if (condition.getType() == DiscountConditionType.PERIOD) {
      discountable = screening.getWhenScreened().getDayOfWeek().equals(condition.getDayOfWeek()) &&
        condition.getStartTime().compareTo(screening.getWhenScreened().toLocalTime()) <= 0 &&
        condition.getEndTime().compareTo(screening.getWhenScreened().toLocalTime()) >= 0;
    } else {
      discountable = condition.getSequence() == screening.getSequence();
    }

    if (discountable) {
      break;
    }
  }
  ....
```



코드를 보면 Screenin이 과 RevervationAgency와 의존 관계가 높은데, 그 이유는 Screening뿐만 아니라 Movie뿐만 아니라 DiscountCondition에도 직접 접근하기 때문이다.



 객체의 내부 구조에 대한 결합으로 인해 발생하는 설계 문제를 해결하기 위해 제안된 원칙이 바로 **디미터 법칙(Law of Demeter)** - 간단하게 요약하면 객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하라는 것.



낮선 자에게 말하지 말라 또는 오직 인접한 이웃하고만 말하라. / 오직 하나의 도트만 사용하라.



클래스 내부의 메서드가 아래 조건을 만족하는 인스턴스에만 메세지를 전송하도록 프로그래밍해야 한다라고 이해해도 무방하다.

- this객체
- 메서드의 매개변수
- this의 속성
- this의 속성인 컬렉션의 요소
- 메서드 내에서 생성된 지역 객체



```java
public class ReservationAgency {
    public Reservation reserve(Screening screening, Customer customer, int audienceCount) {
        Money fee = screening.calculateFee(audienceCount);
        return new Reservation(customer, screening, fee, audienceCount);
    }
}
```



 디미터 법칙을 따르면 부끄럽타는 코드를 작성할 수있다.  
 부끄럼타는 코드란 불필요한 어떤 것도 다른 객체엑 보여주지 않으며, 다른 객체의 구현에 의존하지 않는 코드를 말한다. 디미터 법칙을 따르는 코드는 메시지 수신자의 내부 구조가 전송자에게 노출되지 않으며, 메시지 전송자는 수신자의 내부 구현에 결합되지 않는다. 따라서 클라이언트와 서버 사이에 낮은 결합도를 유지할 수 있다.




### 01.01 묻지말고 시켜라

 디미터 법칙은 훌룡한 메시지는 객체의 상태에 관해 묻지 말고 원하는 것을 시켜야 한다는 사실을 강조한다. **묻지말고시켜라** 는 이런 스타일의 메시지 작성을 장려하는 원칙을 가리키는 용어다.



**메시지 전송자는 메시지 수신자의 상태를 기반으로 결정을 내린 후 메시지 수신자의 상태를 바꿔서는 안된다.** 여러분이 구현하고 있는 로직은 메시지 수신자가 담당해야 할 책임일 것이다. 객체의 외부에서 해당 객체의 상태를 기반으로 결정을 내리는 것은 객체의 캡슐화를 위반한다.



묻지 말고 시켜라 원칙을 따르면 밀접하게 연관된 정보와 행동을 함께 가지는 객체를 만들 수 있다. 객체지향의 기본은 함께 변경될 확률이 높은 정보와 행동을 하나의 단위로 통합하는 것이다. 묻지말고 시켜라 원칙을 따르면 객체의 정보를 이용하는 행동을 객체의 외부가 아닌 내부에 위치시키 떄문에 자연스럽게 정보와 행동을 동일한 클래스 안에 두게 된다. 묻지말고 시켜라 원칙을 딸르도록 메시지를 결정하다 보면 자연스럽게 정보 전문가에게 책임을 할당하게 되고 높은 응집도를 가진 클래스를 얻을 확률이 높아진다.



묻지말고 시켜라 원칙과 디미터 법칙은 훌룡한 인터페이스를 제공하기 위해 포함해야 하는 오퍼레이션에 대한 힌트를 제공한다. 내부의 상태를 묻는 오퍼레이션을 인터페이스에 포함시키고 있다면 더 나은 방법은 없는지 고민하라. 



내부의 상태를 이용해 어떤 결정을 내리는 로직이 객체 외부에 존재하는가? 그렇다면 해당 객체가 책임져야 하는 어떤 행동이 객체 외부로 누수된 것이다.



**상태를 묻는 오퍼레이션을 행동을 요청하는 오퍼레이션으로 대체함으로써 인터페이스를 향상시켜라. 협력을 설계하고 객체가 수신할 메시지를 결정하는 매 순간 묻지말고 시켜라 원칙과 디미터 법칙을 머릿속에 떠올리는 것은 퍼블릭 인터페이스의 품질을 향상킬 수 있는 좋은 습관이다.**



하지만 단순하게 객체에게 묻지 않고 시킨다고 해서 모든 문제가 해결되는 것은 아니다. 훌룡한 인터페이스를 수확하기 위해서는 객체가 어떻게 작업을 수행하는지를 노출해서는 안된다. **인터페이스는 객체가 어떻게 하는지가 아니라 무엇을 하는지를 서술해야 한다.**



### 01.02 의도를 드러내는 인터페이스

- 메서드를 명명하는 두 가지 방법을 소개하는데, 첫번째 방법은 메서드가 작업을 어떻게 수행하는지를 나타내도록 이름 짓는 것., 이 경우 메서드의 이름은 내부의 구현 방법을 드러낸다.   
  그에 따라 아래와 같이 이름을 명명했다.

  ```java
  public class PeriodCondition{
    public boolean isSatisfiedByPeriod(Screening screening) { ... }
  }
  
  public class SequenceCondition{
    public boolean isSatisfiedBySequence(Screening screening) { ... }
  }
  ```

  이런 스타일은 좋지 못하는데,

  - 메서드에 대해 제대로 커뮤니케이션하지 못한다. 클라이언트 관점에서 isSatisfiedByPeriod와 isSatisfiedBySequence 모두 할인 조건을 판단하는 동일한 작업을 수행한다는 사실을 알아채기 어렵다.
  - 더 큰 문젠는 메서드 수준에서 캡슐화를 위반한다는 것. 이 메서드들은 클라이언트로 하여금 협력하는 객체의 종류를 알도록 강요한다. PeriodCondition을 사용하는 코드를 SequenceCondition 을 사용하도록 변경하려면 단순히 참조하는 객체를 변경하는 것뿐만 아니라 호출하는 메서드를 변경해야 한다. 만약 할인 여부를 판단하는 방법이 변경된다면 메서드의 이름 역시 변경해야 할 것이다. 메서드 이름을 변경한다는 것은 메시지를 전송하는 클라이언트의 코드도 함께 변경해야 한다는 것을 의미한다. 따라서 책임을 수행하는 방법을 드러내는 메서드를 사용한 설께는 변경에 취약할 수밖에 없다.

  메서드 이름을 짓는 두번째 방법은 '어떻게'가 아니라 '무엇'을 하는지를 드러내야는 것이다. 메서드의 구현이 한 가지인 경우에는 무엇을 하는지를 드러내는 이름을 짓는 것이 어려울 수 있다. 하지만 무엇을 하는지를 드러내는 이름은 코드를 읽고 이해하기 쉽게 만들 뿐만 아니라 유연한 코드를 낳는 지름길이다.  
  아마 무엇을 하는지를 드러내는 메서드 이름이 설계의 유연성을 향상시킨다는 말이 쉽게 이해되지 않을 것이다.  
   어떻게 수행하는지를 드러내는 이름이란 메서드의 내부 구현을 설명하는 이름이다. 결과적으로 협력을 설계하기 시작하는 이른 시기부터 클래스의 내부 구현에 관해 고민할 수밖에 없다. **반면 무엇을 하는지를 드러내도록 메서드의 이름을 짓기 위해서는 객체가 협력 안에서 수행해야 하는 책임에 관해 고민해야 한다. 이것은 외부의 객체가 메시지를 전송하는 목적을 먼저 생각하도록 만들며, 결과적으로 협력하는 클라이언트의 의도에 부합하도록 메서드의 이름을 짓게 된다.**  

  이제 위 두 개의 메서드를 변경하면  PeriodCondition .isSatisfiedBy //  SequenceCondityion .isSatisfiedBy

  어떻게 하느냐가 아니라 무엇을 하느냐에  따라 메서드의 이름을 짓는 패턴을 **의도를 드러내는 선택자** 라고 부른다.  캔트 백은 메서드의 의도를 드러낼 수 있는 이름을 붙이기 위해 다음과 같이 생각할 것을 조언한다.

  ```
  하나의 구현을 가진 메시지의 이름을 일반화하도록 도와주는 간단한 훈련 방법을 소개하겠다. 매우 다른 두 번째 구현을 상상하라. 그러고는 해당 메서드에 동일한 이름을 붙인다고 상상해보라. 그렇게 하면 아마도 그 순간에 여러분이 할 수 있는 한 가지 추상적인 이름을 메서드에 붙일 것이다.
  ```



객체에게 묻지 말고 시키되 구현 방법이 아닌 클라이언트의 의도를 드러내야 한다. 이것이 이해하기 쉽고 유연한 동시에 협력적인 객체를 만드는 가장 기본적인 요구사항이다.



 디미터 법칙은 객체 간의 협력을 설계할 때 캡슐화를 위반하는 메시지가 인터페이스에 포함되지 않도록 제시한다. 묻지말고 시켜라 원칙은 디미터 법칙을 준수하는 협력을 만들기 위한 스타일을 제시한다.



여기서 멈추지 마라. 의도를 드러내는 인터페이스 원칙은 객체은 객체의 퍼블릭 인터페이스에 어떤 이름이 드러나야 하는지에 대한 지침을 제공함으로써 코드의 목적을 명확하게 커뮤니케이션할 수 있게 해준다.

# 3. 원칙의 함정

## 디미터 법칙은 하나의 도트(.)를 강제하는 규칙이 아니다.

  Java8은 기차충돌에 해당되지 않는다. 
## 결합도와 응집도의 충돌 

묻지말고 시켜라 라는 내용이 무조건 정답은 아니다. 가끔 묻는것도 필요하다라는 것을 말하고 있다.

### 01.03 명령-퀴리 분리



---

# 4. 결론

## 책임에 초점을 맞쳐라

"디미터 법칙을 준수하고 묻지 말고 시켜라 스타일을 따르면서도 의도를 드러내는 인터페이스를 설계하라는 아주 쉬운방법"

- 메시지를 먼저 선택하고 그 후에 메시지를 처리할 객체를 선택하는 것.

- 명령과 쿼리를 분리하고 계약에 의한 설계 개념을 통해 객체의 협력 방식을 명시적으로 드러낼 수 있는 방법
- 객체의 구현 이전에 객체 사이의 협력에 초점을 맞추고 협력 방식을 단순하고 유연하게 만드는 것.

이 모든 방식의 중심에는 객체가 수행할 책임이 위치한다.



`메시지를 먼저 선택하는 방식`이 디미터법칙, 묻지말고 시켜라 스타일, 의도를 드러내는 인터페이스, 명령-쿼리 분리 원칙에 미치는 긍정적인 영향은 다음과 같다.

- **디미터 법칙** - 협력이라는 컨텍스트 안에서 객체보다 메시지를 먼저 결정하면 두 객체 사이의 구조적인 결합도를 낮출 수 있다. 수신할 객체를 알지 못한 상태에서 메시지를 먼저 선택하기 때문에 객체의 내부 구조에 대해 고민할 필요가 없어진다. 따라서 메시지가 객체를 선택하게 함으로써 의도적으로 디미터 법칙을 위반할 위험을 최소화할 수 있다.
- **묻지말고시켜라** - 메시지를 먼저 선택하면 묻지 말고 시켜라 스타일에 따라 협력을 구조화하게 된다. 클라이언트의 관점에서 메시지를 선택하기 때문에 필요한 정보를 물을 필요 없이 원하는 것을 표현할 메시지를 전송하면 된다.
- **의도를 드러내는 인터페이스** - 메시지를 먼저 선택했다는 것은 메시지를 전송하는 클라이언트의 관점에서 메시지의 이름을 정한다는 것. 당연히 그 이름에는 클라이언트가 무엇을 원하는지, 그 의도가 분명하게 드러날 수밖에 없다.
- **명령-쿼리 분리 원칙** - 메시지를 먼저 선택한다는 것은 협력이라는 문맥안에서 객체의 인터페이스에 관해 고민한다는 것을 의미한다. 객체가 단순히 어떤 일을 해야 하는지뿐만 아니라 협력 속에서 객체의 상태를 예측하고 이해하기 쉽게 만들기 위한 방법에 관해 고민하게 된다. 따라서 에측 가능한 협력을 만들기 위해 명령과 쿼리를 분리하게 될 것이다.



***책임주도설계원칙 - 객체가 메시지를 선택하는 것이 아니라 메시지가 객체를 선택하기 때문에 협력에 적합한 메시지를 결정할 수 있는 확률이 높아진다.*** 




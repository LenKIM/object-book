# 다형성

앞 장에서 코드재사용에 대한 내용을 다루면서 상속과 합성에 대한 차이점을 이해했다.

> **복습**
>
> 코드 재사용을 위해서 상속을 사용하는 것이 아닌, 상속은 타입 계층을 구조화하기 위해 사용해야 한다.
>
> 상속을 사용하는 목적은 클라이언트 관점에서 인스턴스들을 동일하게 행동하는 그룹으로 묶기 위해서이다.



상속의 관점에서 다형성이 구현되는 기술적인 메커니즘을 살펴보자.

### 다형성

이 런타임에 메시지를 처리하기에 적합한 메서드를 동적으로 탐색하는 과정을 통해 구현되며, 상속이 이런 메서드를 찾기 위한 일종의 탐색 경로를 클래스 계층의 형태로 구현하기 위한 방법이라는 사실을 이해해야 한다.



## 다형성(Polymorphism) 의 종류

- Universal
  - Parametric(매개변수)
  - Inclusion(포함)
- AdHoc(임시)
  - Overloading(오버로딩)
  - Coercion(강제)



**오버로딩 다형성이란?**

- 하나의 클래스 안에 동일한 이름의 메서드가 존재하는 경우



**강제 다형성이란?**

- 언어가 지원하는 타입 변환이나 사용자가 직접 구현한 타입 변환을 이용해 동일한 연산자를 다양한 타입에 사용할 수 있는 방식



**매개변수 다형성?**

- 제네릭 프로그래밍과 관련이 높은데 클래스의 인스턴스 변수나 메서드의 매개변수 타입을 임의의 타입으로 선언한 후 사용하는 시점에 구체적인 타입으로 지정하는 방식.

  > List<T>



**포함 다형성이란?**

- 메시지가 동일하더라도 수신한 객체의 타입에 따라 실제로 수행되는 행동이 달라지는 능력을 의미. 포함 **다형성은 서브타입(Subtype)** 다형성이라고도 부른다.
- **포함 다형성을 구현하는 가장 일반적인 방법은 상속을 사용하는 것.** 
- 포함 다형성을 위해 상속을 사용하는 가장 큰 이유는 상속이 클래스들을 계층으로 쌓아 올린 후 상황에 따라 적절한 메서드를 선택할 수 있는 매커니즘을 제공하기 때문
- 객체가 메시지를 수신하면 객체 지향 시스템은 메시지를 처리할 적절한 메서드를 상속 계층 안에서 탐색
- 실할 메서드를 선택하는 기준은 어떤 메시지를 수신했는지에 따라, 어떤 클래스의 인스턴스인지에 따라, 상속 계층이 어떻게 구성돼 있는지에 따라 달라짐.



## 상속의 양면성

 객체지향 패러다임의 근간을 이루는 아이디어는 **데이터와 행동**을 객체라고 불리는 하나의 실행 단위안으로 통합하는 것이므로, 객체지향 프로그래밍을 한다라면 **데이터와 행동**이라는 두가지 관점을 늘 고려해야 한다.



상속을 예로 들으면,

데이터 관점 - 부모 클래스에서 정의한 모든 데이터를 자식 클래스의 인스턴스에 자동으로 포함시킬 수 있다.

행동의 관점 - 데이터뿐만 아니라 부모클래스에서 정의한 일부 메서드 역시 자동으로 자식 클래스에 포함 시킬 수 있다.



- 다시 말하지만, 상속의 목적은 코드 재사용이 아니라, 프로그램을 구성하는 개념들을 기반으로 다형성을 가능하게 하는 타입 계층을 구축하기 위한 것



### 상속의 매커니즘을 이해하기 위해 필요한 개념

- 업캐스팅
- 동적 메서드 탐색
- 동적 바인딩
- self 참조
- super 참조



#### 업캐스팅과 동적 바인딩

- 부모 클래스 타입으로 선언된 변수에 자식 클래스의 인스턴스를 할당하는 것이 가능하다. 이를 ***업캐스팅*** 이라 하며, 업캐스닝은 서로 다른 클래스의 인스턴스를 동일한 타입에 할당하는 것이 가능하하다.
- 선언된 변수의 타입이 아니라 메시지를 수신하는 객체의 타입에 따라 실행되는 메서드가 결정된다. 이것은 객체지향 시스템이 메시지를 처리할 적절한 메서드를 컴파일 시점이 아니라 실행 시점에 결정하기 때문에 가능하다. 이를 ***동적 바인딩***
-  GradeLecture > Lecture > Object 의 방향은 업캐스팅 / 반대는 다운 캐스팅이라 한다.
- 무한한 확장 가능성은 가지고 있지만, 개방 폐쇄 원칙에는 맞지 않는다. 업캐스팅은 자식이 부모를 바라보고 있는 상태를 말하는데, 그렇게 될 경우 여러개의 자식 클래스를 확장할 수는 있지만, 동시 수정이라는 문제를 가질 수 밖에 없다.

### 동적 메서드 탐색과 다형성

객체지향 시스템은 다음 규칙에 따라 실행할 메서드를 선택한다.

- 메시지를 수신한 객체는 먼저 자신을 생성한 클래스에 적합한 메서드가 존재하는지 검사한다. 존재하면 메서드를 실행하고 탐색을 종료한다
- 메서드를 찾지 못한다면 부모 클래스에서 메서드 탐색을 계속한다. 이 과정은 적합한 메서드를 찾을 때까지 상속 계층을 따라 올라가며 계속된다.
- 상속 계층을 가장 최상위 클래스에 이르렀지만 메서드를 발견하지 못한 경우 예외를 발생시키며 탐색을 중단한다.



메시지 탐색에서는 `self 참조` 라는 중요한 개념을 이해해야 한다.

- 객체가 메시지를 수신하면 컴파일러는 self 참조라는 임시 변수를 자동으로 생성한 후 메시지를 수신한 객체를 가리키도록 설정.
- 자바에서는 **this**, 파이선은 **self**
- 자동으로 상위 클래스를 탐색하는 **자동적인 메시지 위임**

- 메서드를 탐색하기 위한 **동적인 문맥**, 메시지를 수신했을 때 실제로 어떤 메서드를 실행할지를 결정하는 것은 컴파일 시점이 아닌 실행 시점에 이뤄지며, 메서드를 탐색하는 경로는 self 참조를 이용해서 결정한다.
- `self 전송` 의미 기억하기. 자신에게 다시 메시지를 전송한다. 즉, 현재 클래스의 메서드를 호출하는 것이 아니라 현재 객체에게 메시지를 전송하는 것! 여기서 현재 객체란? 바로 `self` 참조가 가리키는 객체.



### self 대 super

- self 참조는 메시지를 수신한 객체의 클래스에 따라 메서드 탐색을 위한 문맥을 실행 시점에 결정
- self의 이런 특성과 대비해서 언급할 만한 가치가 있는 것은 바로 **super 참조(super reference)**

``super 참조를 이용해 부모 클래스에게 evaluate 메시지를 전송``

이 의미는 단순히 부모 클래스의 메서드를 호출하는 것이 아니라, 더 상위에 위치한 조상 클래스의 메서드일 수도 있다. 라는 것!!

- super 참조를 통해 메시지를 전송하는 것은 마치 부모 클래스의 인스턴스에게 메시지를 전송하는 것처럼 보이기 때문에 이를 super 전송(super send) 이라고 부른다.
- **self 전송이 메시지를 수신하는 객체의 클래스에 따라 메서드를 탐색할 시작 위치를 동적으로 결정하는 데 비해 super 전송은 항상 메시지를 전송하는 클래스의 부모 클래스에서부터 시작된다.**



## 상속 대 위임

다형성은 self 참조가 가리키는 현재 객체에게 메시지를 전달하는 특성을 기반으로 한다. 동일한 타입의 객체 참조에게 동일한 메시지를 전송하더라도 self 참조가 가리키는 객체의 클래스가 무엇이냐에 따라 메서드 탐색을 위한 문맥이 달라진다.

즉, 상속은 자식 클래스에서 부모 클래스로 self 참조를 전달하는 메커니즘으로 상속을 바라보는 것이다.



자신이 수신한 메시지를 다른 객체에게 동일하게 전달해서 처리를 요청하는 것을 **위임(delegation)**

- 위임은 본질적으로 자신이 정의하지 않거나 처리할 수 없는 속성 또는 메서드의 탐색 과정을 다른 객체로 이동시키기 위해 사용한다. 이를 위해 위임은 항상 현재의 실행 문맥을 가리키는 self 참조를 인자로 전달. 이것이 바로 **self 참조를 전달하지 않는 포워딩과 위임의 차이점**
- 상속관계에서 연결된 클래스 사이에는 자동적인 메시지 위임이 일어난다고 설명했다. 이제 왜 *위임*이라는 단어를 사용했는지 이해할 수 있을 것이다. 상속은 동적으로 메서드를 탐색하기 위해 현재의 실행 문맥을 가지고 있는 self 참조를 전달한다.